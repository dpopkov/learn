2.1.1 Цели ООП
--------------

### Прочность

Каждый программист хочет разработать правильный софт, что значит, что программа производит правильный
результат для всех предвиденных вводов. В дополнение к этому, мы хотим чтобы софт был __прочный__, то есть
способный обработать непредвиденный ввод не определенный для данного приложения. К примеру, если 
программа ожидает положительное целое число, а вместо этого получает отрицательное, то программа
должна быть способна восстановиться после этой ошибки. Что еще важнее, в жизненно-критических приложениях,
где ошибка можит стоить человеческой жизни, __непрочный__ софт является смертельно опасным. Иллюстрацией
к этом служит печально известный инцидент с Therac-25, машиной радиационной терапии, которая подвергла
шестерых пациентов передозировке радиации, приведший к нескольких смертям. Все шесть случаев произошли
из-за ошибок в софте.  

### Адаптируемость

Современный софт, такой как веб-браузеры и поисковые систем включают в себя большие программы используемые
на протяжении многих лет. Софт, следовательно, должен быть способным развиваться с течением времени
в отвест на изменяющиеся условия. Помимо прочности, другой важной целью качественного софта является 
__адаптируемость__ и связанная с ней __переносимость__, то есть способность работать с минимальными 
изменениями на разных платформах.

### Повторное использование

Один и тот же код должен использоваться как компонент различных систем в разных приложениях. 
Разработка качественного софта является дорогим предприятием и его цена может быть снижена если
софт разработан с учетом возможного повторного использования в будущих приложениях. 
Однако это должно делаться с осторожностью, примером тут является то, что главным источником ошибок
в Therac-25 был использованный софт для Therac-20, не предназначенный для Therac-25.


2.1.2 Принципы ООП
------------------

### Абстракция

Понятие __абстракции__ заключается в том, что сложная система должна быть сведена к ее наиболее
фундаментальным частям. Обычно описание частей системы включает в себя их название и объяснение 
их функциональности. Применение принципа __абстракции__ к дизайну структур данных порождает 
__абстрактные типы данных__ (__ADT__). ADT это модель структуры данных определяющая тип хранимых данных,
поддерживаемые операции, и типы параметров этих операций. ADT определяет __что__ делает каждая операция,
но не __как__ она это делает. В Java ADT выражаются интерфейсами, то есть списками объявлений методов, 
где каждый метод имеет пустое тело.

ADT реализуется конкретной структурой данных - классом. Класс определяет хранимые данные и операции
поддерживаемые объектами данного класса. И в отличие от интерфейсов классы определяют __как__ эти
операции выполняются в теле каждого метода. Класс имплементирует интерфейс если его методы включают
все методы объявленные в интерфейсе и имеют тела реализации.

### Инкапсуляция

Различные компоненты системы не должны показывать внутренние детали своей реализации. Одним из главных
преимуществ инкаспуляции является свобода реализовывать детали компонента, не испытывая беспокойства 
что другие программисты будут писать код хитроумно использующий внутренние особенности этого компонента, 
то есть зависимый от его реализации. Единственным ограничением для создающего компонент является 
обязанность поддерживать внешний интерфейс компонента, так как другие программисты будут зависеть
от этого внешнего интерфейса. Инкапсуляция порождает прочность и адаптируемость, поскольку она позволяет
деталям внутренней реализации компоняента изменяться не ломая при этом другие части приложения,
делая более легким исправление багов и добавление новой функциональности, внося только локальные
изменения в компонент.

### Модульность

Современные системы обычно состоят из нескольких различных компонентов, которые должны взаимодействовать
между собой корректно чтобы целая система работала надлежащим образом. Сохранение прямых взаимодействий
между компонентами требует чтобы эти компоненты были хорошо организованы. __Модульность__ ссылается
на организующий принцип, согласна которому различные компоненты системы разделены на отдельные
функциональные модули. Прочность повышается благодаря тому, что отдельные компоненты легче тестировать
и отлаживать до того, как они интегрированы в более крупную систему. 


2.1.3 Шаблоны проектирования
----------------------------

Решения типичной задачи проектирования.

Алгоритмические шаблоны:  
* Recursion (Chapter 5)
* Amortization (Sections 7.2.3, 11.4.4, and 14.7.3)
* Divide-and-conquer (Section 12.1.1)
* Prune-and-search, also known as decrease-and-conquer (Section 12.5.1)
* Brute force (Section 13.2.1)
* The greedy method (Sections 13.4.2, 14.6.2, and 14.7)
* Dynamic programming (Section 13.5)

Шаблоны проектирования:
* Template method (Sections 2.3.3, 10.5.1, and 11.2.1)
* Composition (Sections 2.5.2, 2.6, and 9.2.1)
* Adapter (Section 6.1.3)
* Position (Sections 7.3, 8.1.2, and 14.7.3)
* Iterator (Section 7.4)
* Factory Method (Sections 8.3.1 and 11.2.1)
* Comparator (Sections 9.2.2, 10.3, and Chapter 12)
* Locator (Section 9.5.1)

### Template method

An abstract base class provides a concrete behavior that relies upon calls to other abstract behavior
as in learn.dsajg6e.ch02oop.AbstractProgression::advance method.